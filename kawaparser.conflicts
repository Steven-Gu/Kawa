
** Conflict (shift/reduce) in state 132.
** Token involved: RETURN
** This state is reached from program after reading:

var_decls CLASS IDENT BEGIN attr_decls METHOD typ IDENT LPAR params RPAR BEGIN var_decls

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
var_decls classes MAIN BEGIN seq END EOF 
          class_def classes 
          CLASS IDENT BEGIN attr_decls method_defs END 
                                       method_def method_defs 
                                       (?)

** In state 132, looking ahead at RETURN, shifting is permitted
** because of the following sub-derivation:

METHOD typ IDENT LPAR params RPAR BEGIN var_decls seq RETURN expression SEMI END 
                                                  instruction seq 
                                                  . RETURN expression SEMI 

** In state 132, looking ahead at RETURN, reducing production
** seq ->
** is permitted because of the following sub-derivation:

METHOD typ IDENT LPAR params RPAR BEGIN var_decls seq RETURN expression SEMI END // lookahead token appears
                                                  . 

** Conflict (shift/reduce) in state 127.
** Token involved: RETURN
** This state is reached from program after reading:

var_decls CLASS IDENT BEGIN attr_decls METHOD typ IDENT LPAR params RPAR BEGIN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
var_decls classes MAIN BEGIN seq END EOF 
          class_def classes 
          CLASS IDENT BEGIN attr_decls method_defs END 
                                       method_def method_defs 
                                       (?)

** In state 127, looking ahead at RETURN, shifting is permitted
** because of the following sub-derivation:

METHOD typ IDENT LPAR params RPAR BEGIN . RETURN expression SEMI END 

** In state 127, looking ahead at RETURN, reducing production
** var_decls ->
** is permitted because of the following sub-derivation:

METHOD typ IDENT LPAR params RPAR BEGIN var_decls seq RETURN expression SEMI END // lookahead token appears because seq can begin with RETURN
                                        . 

** Conflict (shift/reduce) in state 112.
** Token involved: RETURN
** This state is reached from program after reading:

var_decls CLASS IDENT BEGIN attr_decls METHOD typ IDENT LPAR params RPAR BEGIN var_decls instruction

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
var_decls classes MAIN BEGIN seq END EOF 
          class_def classes 
          CLASS IDENT BEGIN attr_decls method_defs END 
                                       method_def method_defs 
                                       (?)

** In state 112, looking ahead at RETURN, shifting is permitted
** because of the following sub-derivation:

METHOD typ IDENT LPAR params RPAR BEGIN var_decls seq RETURN expression SEMI END 
                                                  instruction seq 
                                                              instruction seq 
                                                              . RETURN expression SEMI 

** In state 112, looking ahead at RETURN, reducing production
** seq ->
** is permitted because of the following sub-derivation:

METHOD typ IDENT LPAR params RPAR BEGIN var_decls seq RETURN expression SEMI END // lookahead token appears
                                                  instruction seq // lookahead token is inherited
                                                              . 

** Conflict (shift/reduce) in state 85.
** Tokens involved: REM PLUS OR NEQ MUL MINUS LT LEQ GT GEQ EQUAL DOT DIV AND
** The following explanations concentrate on token REM.
** This state is reached from program after reading:

var_decls classes MAIN BEGIN NOT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
var_decls classes MAIN BEGIN seq END EOF 
                             instruction seq 
                             expression SEMI 
                             (?)

** In state 85, looking ahead at REM, reducing production
** expression -> NOT expression
** is permitted because of the following sub-derivation:

expression REM expression // lookahead token appears
NOT expression . 

** In state 85, looking ahead at REM, shifting is permitted
** because of the following sub-derivation:

NOT expression 
    expression . REM expression 

** Conflict (shift/reduce) in state 21.
** Token involved: IDENT
** This state is reached from program after reading:

var_decls CLASS IDENT BEGIN attr_decls METHOD VOID

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
var_decls classes MAIN BEGIN seq END EOF 
          class_def classes 
          CLASS IDENT BEGIN attr_decls method_defs END 
                                       method_def method_defs 
                                       (?)

** In state 21, looking ahead at IDENT, shifting is permitted
** because of the following sub-derivation:

METHOD VOID . IDENT LPAR params RPAR BEGIN var_decls seq END 

** In state 21, looking ahead at IDENT, reducing production
** typ -> VOID
** is permitted because of the following sub-derivation:

METHOD typ IDENT LPAR params RPAR BEGIN var_decls seq RETURN expression SEMI END // lookahead token appears
       VOID . 
