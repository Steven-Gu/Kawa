Ce projet a été réalisé conjointement par GU Tianwen et ZHANG Hongfei. Son objectif était de construire et d'interpréter un langage de programmation miniaturisé semblable à Java, nommé Kawa, en utilisant les outils ocamllex et menhir fournis par OCaml. Après des tests rigoureux, notre langage Kawa s'est avéré capable d'exécuter parfaitement tous les tests inclus, depuis les calculs et commandes de base jusqu'à la création et l'implémentation de méthodes de classe, ainsi que l'héritage de classe.

Notre projet se divise en deux parties principales : l'analyse lexicale et syntaxique, et la vérification de type avec l'interprétation. Dans la première partie, la difficulté principale a été la gestion de certains conflits shift/reduce. Le conflit shift/reduce le plus important dans le parser s'est manifesté dans la définition de method_def. Initialement, nous avions inclus une instruction return dans cette définition, distinguant les méthodes void et non-void. Cela a entraîné une situation où un shift et un reduce étaient tous deux possibles dans cette section. Nous n'avions pas réalisé que l'instruction return était déjà comprise dans les instructions. Par conséquent, notre classification des méthodes était superflue. Il n'était pas nécessaire d'ajouter un jeton return supplémentaire dans la définition de method_def. Après avoir simplifié cette partie, nous avons résolu ce problème.

Dans la seconde partie, les difficultés se sont concentrées sur la gestion des classes. Dans le typechecker, la vérification de methcall était la plus complexe. Il fallait non seulement vérifier l'existence de la classe et de la méthode, mais aussi s'assurer que les types des paramètres de la classe étaient corrects. Nous avons finalement utilisé plusieurs fonctions auxiliaires pour simplifier et résoudre ce problème. Un autre défi a été l'intégration de l'héritage de classe. Au début, nous nous heurtions souvent à des problèmes d'attributs non trouvés, car certains attributs appartenaient à la classe parente et n'étaient pas définis dans la sous-classe. Il était donc nécessaire de vérifier également les attributs de la classe parente. De plus, des erreurs telles que « expected ‘parent class’, got ‘subclass’ » se produisaient, car la fonction de vérification originale se contentait de comparer simplement deux types sans tenir compte de l'héritage. Après avoir intégré la fonction is_subtype, nous avons résolu ce problème.

Dans la partie interpréteur, deux problèmes majeurs ont surgi. Le premier était de savoir comment garder en mémoire la classe actuelle, c'est-à-dire la valeur de this. Finalement, nous avons opté pour une méthode de référence, avec let current_object = ref None, définissant ainsi current_object globalement pour enregistrer cette information. Le second problème concernait la gestion des environnements global et local. Au début, nous n'étions pas sûrs de comment utiliser ces deux environnements simultanément et de les effacer après leur utilisation temporaire. Finalement, nous avons décidé de créer et d'utiliser un environnement temporaire uniquement dans la fonction eval_call, qui est automatiquement détruit après son exécution. En outre, l'utilisation de cette fonction posait un problème : lors de l'utilisation de la méthode du constructeur, nous nous attendions à recevoir un nouvel objet et non la valeur de retour void de la méthode elle-même, tandis que pour d'autres méthodes de classe, nous souhaitions obtenir la valeur de retour. Dans ces deux cas, nous avions besoin d'utiliser la fonction eval_call, nous avons donc décidé de retourner une paire composée d'un objet et d'une valeur. Ainsi, nous pouvions gérer efficacement ces deux situations.

